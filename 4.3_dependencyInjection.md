# Dependency Injection (DI) — Full deep dive (Spring Boot)

This single document explains **why DI is needed**, **how Spring performs DI**, the **three injection styles** (field, setter, constructor) with deep internals, **common problems** (NPE, circular dependency, ambiguous beans) and **practical solutions** and **unit-testing tips**. Examples use simple `User`, `Order`, and `Test` classes.

---

## Quick summary

* **Tight coupling** (using `new`) makes code rigid and hard to test.
* **DI** flips responsibility to the container: Spring creates and wires beans.
* Prefer **constructor injection** for mandatory deps, use **setter** for optional/mutable deps, and avoid **field injection** for most cases.
* Understand how Spring resolves beans (`@Autowired` by type, qualifiers, primary) and how it handles circular references for singleton beans.

---

## 1) Problem: tight coupling (why `new` is bad)

### Example (tight coupling — bad)

```java
public class Order {
    public void process() { System.out.println("Order processed"); }
}

public class User {
    private Order order = new Order(); // tightly coupled

    public void process() { order.process(); }
}
```

Problems:

* `User` decides which `Order` implementation to use — no flexibility.
* Hard to replace `Order` with a mock in tests.
* Any change in `Order` constructor or behavior can force change in `User`.

**Goal:** decouple `User` from `Order` so the application is flexible and testable.

---

## 2) How DI solves the problem

* Spring's IoC container creates beans and injects them where needed.
* `@Component`, `@Service`, `@Repository`, `@Controller` register beans; `@Configuration` + `@Bean` explicitly defines them.
* `@Autowired` tells Spring to find a bean of the requested type and set it.

Example (loose coupling):

```java
@Component
public class Order { public void process(){ System.out.println("Order processed"); } }

@Component
public class User {
    private final Order order; // injected

    @Autowired
    public User(Order order) { this.order = order; }

    public void process(){ order.process(); }
}
```

Now `User` depends on an abstraction (type `Order`) but not on who creates it.

---

## 3) How `@Autowired` works (resolution rules)

* **By type**: Spring first collects candidate beans whose class matches the injection type.
* **If exactly one candidate** → injected.
* **If multiple candidates** → Spring looks for a matching bean name, `@Qualifier`, or `@Primary`. Otherwise an exception is thrown.
* **Required flag**: `@Autowired(required = true)` (default). If no bean found, exception. Set `required=false` to make injection optional.
* **Optional injection**: you can autowire `Optional<Order>` or `@Nullable Order` to handle absence.

Internally, when wiring, Spring reads the bean definitions, creates the bean instances according to scope and lifecycle, and resolves dependencies by type and qualifiers.

---

## 4) Three styles of injection — deep details, pros & cons, examples

### A. Field injection

**Code**

```java
@Component
public class User {
    @Autowired
    private Order order; // injected by reflection

    public void process(){ order.process(); }
}
```

**How it works (internals)**

* Spring uses reflection (via `java.lang.reflect.Field`) to set the field value after instantiation.
* Steps: instantiate `User` (call constructor), then `populateProperties()` — Spring finds `@Autowired` fields and calls `field.setAccessible(true)` then `field.set(instance, dependency)`.

**Reflection** — short explainer:

* Reflection is Java's runtime API to inspect classes, constructors, fields, and methods, and to access/modify them at runtime even if they're `private`.
* Example: `Field f = User.class.getDeclaredField("order"); f.setAccessible(true); f.set(userInstance, new Order());`

**Why `final` is problematic**

* `final` fields are intended to be set during construction and remain constant.
* Field injection sets the field after construction — so you cannot reliably have `final` values because Java semantics expect `final` assigned in the constructor.
* Technically reflection *can* set `final` fields in some JVMs (with `setAccessible(true)`), but it breaks the immutability contract and can lead to undefined behavior or optimizer-related surprises. Spring discourages this — field injection with `final` is against design and can be unsupported.

**NullPointerException risk**

* If you create an object manually via `new User()` (outside the container), Spring does not manage it and will not inject dependencies. Example:

```java
User userObj = new User(); // not managed by Spring
userObj.process(); // order == null -> NPE
```

* `@Autowired` only runs for beans created by the Spring context.

**Unit testing difficulty**

* Field injection makes it harder to pass mocks because fields are private and set by Spring. You either:

  * use Spring test support to autowire and run with Spring, or
  * use reflection helpers (e.g., `ReflectionTestUtils.setField(user, "order", mockOrder)`), or
  * use Mockito's `@InjectMocks` which uses reflection to inject mocks — but these require more test plumbing.

**Pros**: minimal boilerplate.
**Cons**: hard to test, can't be `final`, leads to hidden dependencies; not recommended for production code.

### B. Setter injection

**Code**

```java
@Component
public class User {
    private Order order;

    public User() { System.out.println("User created"); }

    @Autowired
    public void setOrder(Order order) {
        this.order = order;
    }
}
```

**How it works (internals)**

* Spring creates the `User` instance (constructor call).
* During property population, Spring finds `@Autowired` methods and calls them with resolved dependencies.
* This happens before lifecycle callbacks like `@PostConstruct`.

**Advantages**

* Allows optional/mutable dependencies — you can change the dependency at runtime.
* Easier to mock in tests — just call `user.setOrder(mockOrder)`.

**Disadvantages**

* Cannot make `order` `final` (same reason as field injection — assignment happens after construction).
* Dependencies become mutable which may lead to subtle bugs.
* Slightly more verbose and can clutter API with setter methods intended purely for injection.

**When to prefer**

* When dependency truly is optional or needs to be changed after construction, or when circular dependency demands setter injection.

### C. Constructor injection (preferred)

**Code (recommended)**

```java
@Component
public class User {
    private final Order order;

    @Autowired // optional since Spring 4.3 if only one constructor
    public User(Order order) {
        this.order = order;
    }
}
```

**How it works (internals)**

* Spring chooses the constructor, resolves its parameters (recursively creating required beans), and calls `new User(resolvedOrder)` to create the instance.
* Because dependencies are provided at construction time, the object is fully initialized and immutable (if you use `final`).

**Advantages**

* Guarantees mandatory dependencies are provided (fail-fast at startup).
* Allows `final` fields => immutable design.
* Very easy to unit-test: `new User(mockOrder)`.
* Better for design clarity — all dependencies are explicit in the constructor signature.

**Disadvantages**

* If a class has many dependencies, constructor gets large (code smell; consider splitting responsibilities or grouping dependencies into smaller components).
* If you have multiple constructors, you must annotate which one Spring should use with `@Autowired` (unless only one constructor exists).

**Example: multiple constructors**

```java
@Component
public class User {
    private final Order order;
    private final Test test;

    @Autowired
    public User(Order order) { this.order = order; this.test = null; }

    public User(Test test) { this.order = null; this.test = test; }
}
```

* Without `@Autowired`, Spring may not know which constructor to use.

---

## 5) Common DI problems & solutions (in depth)

### A. NullPointerException (manual instantiation)

**Why:** `@Autowired` wiring is performed by the Spring container as part of bean lifecycle. If you create objects with `new` (outside the container) dependencies are not injected.

**Fixes:**

* Let Spring create the `User` bean (annotate with `@Component` and use `ApplicationContext.getBean(User.class)`), or
* In tests, use dependency injection utilities (Mockito `@InjectMocks` or `ReflectionTestUtils.setField`) or prefer constructor injection so you can pass mocks.

**Example test**

```java
// With constructor injection — easy
Order mockOrder = mock(Order.class);
User user = new User(mockOrder);
user.process(); // no NPE

// With field injection — harder
User user = new User(); // no Spring wiring
// need reflection to inject mock
ReflectionTestUtils.setField(user, "order", mockOrder);
```

### B. Circular dependency (detailed)

**Problem**: A depends on B and B depends on A (A -> B -> A). Spring must create both. Explanation differs by injection type:

**Setter / Field injection (singleton beans)**
Spring can resolve circular references for singleton-scoped beans using a three-step mechanism:

1. **Instantiate** bean A (call constructor) and register an early `singletonFactory` (a factory that can create an early reference or proxy to A) in the singleton cache.
2. **Populate properties**: when injecting A into B, Spring may use the early reference to A (from the factory) to satisfy B's dependency even though A isn't fully initialized yet.
3. **Initialize** A and B (post-processors, `@PostConstruct`, etc.), then replace the early reference with the fully-initialized instance.

This only works for **singleton** beans and **property** (setter/field) injection — because Spring can create the instance first and fill properties later.

**Constructor injection**

* Fails: constructor injection requires creating the other bean *before* you can construct the first bean — Spring cannot satisfy that with only early references, so a circular constructor dependency raises `BeanCurrentlyInCreationException`.

**Solutions**

* **Refactor** to remove the cycle (best option).
* Use **`@Lazy`** on one side: mark one bean as lazy so it is injected as a proxy and resolved on first use (delays creation). Example:

  ```java
  @Component
  public class A { @Autowired @Lazy B b; }

  @Component
  public class B { @Autowired A a; }
  ```

  Here `b` will be injected as a lazy proxy; creating `A` won't force full creation of `B` immediately.
* Use **setter injection** (or field) instead of constructor injection when cycle is unavoidable — because setter allows early references.
* Use **`@PostConstruct`** to set one side after both beans created. Example (from your snippet): create A with no autowired, then B's `@PostConstruct` calls `a.setB(this)`.

**Sequence example with your `@PostConstruct` solution**

1. Spring creates `Order` (lazy) instance. It autowires `Test` field only as a reference or creates `Test` if needed.
2. `Test` has no autowired `Order` (in second version), so `test` is created and `order` remains unset.
3. `Order`'s `@PostConstruct.initialize()` calls `test.setOrder(this)` to set the back reference after both exist.

This defers the circular wiring to an initialization step and avoids constructor-time cycles.

### C. Unsatisfied dependency / multiple implementations

**Problem**: `OrderService` is an interface with two implementations; `@Autowired OrderService` results in `NoUniqueBeanDefinitionException`.

**Solutions**

1. **@Primary**

```java
@Component
@Primary
public class OnlineOrderService implements OrderService { ... }
```

Spring will pick the `@Primary` bean when ambiguous.

2. **@Qualifier**

```java
@Component("offlineService")
public class OfflineOrderService implements OrderService { ... }

@Component
public class User {
    @Autowired
    @Qualifier("offlineService")
    private OrderService orderService;
}
```

This explicitly selects which implementation to inject.

3. **Bean name + @Resource** (by name injection) — `@Resource(name = "offlineService")`.

### D. Prototype vs Singleton injection gotcha

* **Singleton**: default scope — one instance per Spring container. Circular resolution works only for singletons.
* **Prototype**: Spring creates a new instance each time it is requested. If you inject a prototype into a singleton normally, Spring will create the prototype once at injection time and keep that single instance in the singleton. To get new prototypes each time from a singleton, use `ObjectProvider<Order>` or `Provider<Order>`.

Example using `ObjectProvider`:

```java
@Component
public class User {
    private final ObjectProvider<Order> orderProvider;

    @Autowired
    public User(ObjectProvider<Order> orderProvider) { this.orderProvider = orderProvider; }

    public void doSomething() {
        Order order = orderProvider.getObject(); // new prototype each call
    }
}
```

### E. Optional / missing beans

* Use `@Autowired(required=false)` or `Optional<T>` to avoid exceptions on missing beans.
* `@Nullable` parameter also works if your dependency can be absent.

---

## 6) Unit testing: practical examples

**Constructor injection — easiest to test**

```java
@ExtendWith(MockitoExtension.class)
class UserTest {
    @Mock Order order;

    @Test
    void testProcess() {
        User user = new User(order); // direct constructor injection
        user.process();
        verify(order).process();
    }
}
```

**Field injection — needs reflection or Mockito helpers**

```java
class UserTest {
    @Mock Order mockOrder;

    @Test
    void testFieldInjectedUser() {
        User user = new User(); // no Spring wiring
        ReflectionTestUtils.setField(user, "order", mockOrder);
        user.process();
        verify(mockOrder).process();
    }
}
```

Or use Mockito's `@InjectMocks` which will create `User` and inject mocks into fields.

**Integration test with Spring**

* Use `@SpringBootTest` and regular `@Autowired` to get fully wired beans — but these are slower and not unit tests.

---

## 7) Practical recommendations / checklist

* Prefer **constructor injection** for mandatory dependencies.
* Keep constructors small; if too many dependencies, refactor responsibilities.
* Avoid field injection for production code — it hides dependencies and makes testing harder.
* Use `@Qualifier` or `@Primary` to disambiguate multiple candidates.
* Avoid circular dependencies; refactor or use `@Lazy`/setter injection as temporary workaround.
* Use `ObjectProvider`/`Provider` to inject prototype beans into singletons.
* Use `Optional`, `@Nullable` or `required=false` for optional dependencies.

---

## 8) Appendix: small code snippets referenced above

**Manual reflection set (what Spring does under the hood for field injection)**

```java
Field f = User.class.getDeclaredField("order");
f.setAccessible(true);
f.set(userInstance, resolvedOrder);
```

**Using @Qualifier example**

```java
@Component("onlineOrder")
public class OnlineOrderService implements OrderService { }

@Component("offlineOrder")
public class OfflineOrderService implements OrderService { }

@Component
public class User {
    @Autowired
    @Qualifier("offlineOrder")
    private OrderService orderService;
}
```

---

## Final notes

* DI is a fundamental pattern for building modular, testable applications. Spring Boot gives you a mature DI container; learning the lifecycle and resolution rules helps avoid subtle bugs.
* When in doubt: make dependencies explicit (constructor), keep beans single-responsibility, and write focused unit tests.
