# Spring Bean Scopes and Lifecycle

This document covers the detailed explanation of Spring Bean scopes, their lifecycle, behavior, and examples with outputs.

---

## Flow/Lifecycle of a Bean

```mermaid
graph TD
    A[Bean Constructor Initialized] --> B[Check for Dependencies]
    B --> C[Resolve Dependencies if any]
    C --> D[PostConstruct Method]
    D --> E[Finish Remaining Tasks of Bean]
    E --> F[Pre-Destructor Actions]
    F --> G[Destruction of Bean]
````

* **Step 1:** Bean will be initialized using constructor.
* **Step 2:** Check for any dependencies; resolve them first if found.
* **Step 3:** Post-construct initialization.
* **Step 4:** Finish the remaining tasks of the bean.
* **Step 5:** Pre-destruction tasks.
* **Step 6:** Bean is destroyed.

---

## Singleton Scope

* **Definition:** Bean will be initialized only once in an IOC container. The same bean instance is used everywhere.
* **Default Scope:** Singleton.
* **Annotation:** `@Scope("singleton")` or `@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)`
* **Initialization:** Eager (as soon as the application starts).

### Example

**User.java**

```java
@Component
//@Scope("singleton")
//@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)
public class User {
    public User(){
        System.out.println("User initialized ");
    }

    @PostConstruct
    public void init(){
        System.out.println("PostConstruct User initialized: "+this.hashCode());
    }
}
```

**Test.java**

```java
@Component
public class Test {
    @Autowired
    User user;

    public Test(){
        System.out.println("Test initialized ");
    }

    @PostConstruct
    public void init(){
        System.out.println("PostConstruct Test initialized: "+user.hashCode());
    }
}
```

**Order.java**

```java
@Component
public class Order {
    @Autowired
    User user;

    public Order(){
        System.out.println("Oder initialized");
    }

    @PostConstruct
    public void init(){
        System.out.println("PostConstruct Oder initialized: "+user.hashCode());
    }
}
```

**Output:**

```
User initialized
PostConstruct User initialized: 1796911920
Oder initialized
PostConstruct Oder initialized: 1796911920
Test initialized
PostConstruct Test initialized: 1796911920
```

* The hash code for `User` bean is the same every time, confirming singleton behavior.

---

## Prototype Scope

* **Definition:** Each time a new object is created.
* **Initialization:** Lazy, created only when required.

### Example

**User.java**

```java
@Scope("prototype")
@Component
public class User {
    public User(){
        System.out.println("User initialized ");
    }

    @PostConstruct
    public void init(){
        System.out.println("PostConstruct User initialized: "+this.hashCode());
    }
}
```

**Test.java**

```java
@Component
@Scope("prototype")
public class Test {
    @Autowired
    User user;

    @Autowired
    Order order;

    public Test(){
        System.out.println("Test initialized ");
    }

    @PostConstruct
    public void init(){
        System.out.println("PostConstruct Test initialized user: "+user.hashCode());
        System.out.println("PostConstruct Test initialized order: "+order.hashCode());
    }
}
```

**Order.java**

```java
@Scope("singleton")
@Component
public class Order {
    @Autowired
    User user;

    public Order(){
        System.out.println("Oder initialized");
    }
    @PostConstruct
    public void init(){
        System.out.println("PostConstruct Oder initialized: "+user.hashCode());
    }
}
```

**Output & Behavior:**

```
User initialized
PostConstruct User initialized: 1134234005
Oder initialized
User initialized
PostConstruct User initialized: 1245538270
PostConstruct Oder initialized: 1245538270
```

* Prototype beans are lazily initialized.
* Each injection or usage results in a new bean instance.

---

## Request Scope

* **Definition:** A new object is created for each HTTP request.
* **Initialization:** Lazy.

**UdemyController.java**

```java
@RestController
@Scope("request")
@RequestMapping("hi")
public class UdemyController {

    @Autowired
    User user;

    @Autowired
    Order order;

    public UdemyController(){
        System.out.println("UdemyController initialized");
    }

    @PostConstruct
    public void init(){
        System.out.println("PostConstruct UdemyController initialized: "+user.hashCode());
    }

    @GetMapping("/hello")
    public String sayHello(){
        return "Hello";
    }
    @GetMapping("bean")
    public String bean(){
        return "Bean";
    }
}
```

**Output for HTTP request:**

```
UdemyController initialized
User initialized
PostConstruct User initialized: 434522996
Oder initialized
PostConstruct Oder initialized: 434522996
PostConstruct UdemyController initialized: 434522996
```

**Singleton vs Request Scope Problem:**

* If `UdemyController` is singleton and `User` is request scoped, an error occurs because request-scoped bean cannot be injected into a singleton eagerly.
* **Solution:** Use a proxy.

**User.java with Proxy**

```java
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
@Component
public class User {
    public User(){
        System.out.println("User initialized ");
    }

    @PostConstruct
    public void init(){
        System.out.println("PostConstruct User initialized: "+this.hashCode());
    }

    public void doSomething() {
        System.out.println("Inside User.doSomething() for hash: " + this.hashCode());
    }
}
```

* Proxy creates a dummy object for dependency resolution in singleton beans.
* Actual request-scoped bean is created on HTTP request.

---

## Session Scope

* **Definition:** A new object is created per HTTP session.
* **Initialization:** Lazy, remains active until session expires.

**UdemyController.java (Session Scope)**

```java
@RestController
@Scope("session")
@RequestMapping("hi")
public class UdemyController {

    @Autowired
    User user;

    @Autowired
    Order order;

    public UdemyController(){
        System.out.println("UdemyController initialized");
    }

    @PostConstruct
    public void init(){
        System.out.println("PostConstruct UdemyController initialized: "+user.hashCode());
    }

    @GetMapping("/hello")
    public String sayHello(){
        user.doSomething();
        return "Hello" +user.hashCode();
    }

    @GetMapping("/logout")
    public ResponseEntity<String> getUserDetails(HttpServletRequest request){
        System.out.println("end of session");
        HttpSession session = request.getSession();
        session.invalidate();
        return ResponseEntity.status(HttpStatus.OK).body("");
    }
}
```

**Output & Behavior:**

```
User initialized
UdemyController initialized
Oder initialized
PostConstruct Oder initialized: 1109504438
PostConstruct UdemyController initialized: 1109504438
Inside User.doSomething() for hash: 1109504438
```

* Session-scoped bean maintains state per session.
* New session results in new bean instances.

---

## Application Scope

* **Definition:** Similar to singleton but shared across multiple IOC containers.
* Ensures one object per application context.

---

**This completes the detailed documentation covering all scopes, lifecycle, behaviors, proxy usage, and outputs of Spring Beans.**

```
```
