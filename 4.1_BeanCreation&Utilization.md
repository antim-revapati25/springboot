# Spring Boot: Creating Beans with `@Component` and `@Bean`

In Spring Boot, a **bean** is simply an object that is managed by the Spring IoC (Inversion of Control) container. Instead of creating objects manually using `new`, we let Spring create, configure, and inject them where needed. There are two common ways to define a bean in Spring Boot:

---

## 1. Using `@Component`

If you mark a class with `@Component`, Spring automatically detects it during component scanning and creates a bean. Example:

```java
package com.antim.udemySh.service;

import org.springframework.stereotype.Component;

@Component
public class User {
    String username;
    String email;

    public User() {} // Spring requires a default constructor here

    public String getUsername(){return username;}
    public String getEmail(){return email;}
    public void setUsername(String username){this.username=username;}
    public void setEmail(String email){this.email=email;}
}
```

### Key Points
- **Convention over configuration**: Spring automatically registers the bean if it finds `@Component`.
- Requires a **default constructor** because Spring does not know what values to pass in a parameterized constructor by default.
- Fields can later be set using setters or through other injections.

---

## 2. Using `@Bean` inside a `@Configuration` class

If your class has a **parameterized constructor** (and you want full control over its creation), then `@Component` won’t work directly. Instead, you use `@Bean` inside a `@Configuration` class.

### Example: `User` Bean with Parameterized Constructor

`User.java`:
```java
package com.antim.udemySh.service;

public class User {
    String username;
    String email;

    public User(String username, String email){
        this.username = username;
        this.email = email;
    }

    public String getUsername(){return username;}
    public String getEmail(){return email;}
    public void setUsername(String username){this.username=username;}
    public void setEmail(String email){this.email=email;}
}
```

`AppConfig.java`:
```java
package com.antim.udemySh.config;

import com.antim.udemySh.service.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    @Bean
    public User createUserBean(){
        return new User("default", "default@gmail.com");
    }
}
```

Here:
- `@Configuration` tells Spring this class contains bean definitions.
- `@Bean` explicitly defines the bean, and you control how it is created.
- You can pass constructor arguments directly (`"default"`, `"default@gmail.com"`).

---

## 3. Using the `User` Bean in a Controller

```java
package com.antim.udemySh.controller;

import com.antim.udemySh.service.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UdemyController {

    @Autowired
    public User user; // Dependency Injection

    @GetMapping("bean")
    public String bean(){
        return user.getUsername() + " : " + user.getEmail();
    }
}
```

### Key Points
- Spring automatically injects the `User` bean into the controller.
- This works whether the bean was created with `@Component` or `@Bean`.
- With `@Bean`, you can easily provide custom initialization logic (like passing constructor parameters).

---

## Summary

- **`@Component`**: Best when your class has a default constructor and you’re fine with convention.  
- **`@Bean`**: Best when you want fine-grained control, especially for classes with parameterized constructors.  
- Both approaches result in the same outcome: Spring manages the object and injects it where needed.
