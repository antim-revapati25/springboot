# Spring Boot Conditional Bean Creation: @ConditionalOnProperty vs @Profile

This document explains **how to create beans conditionally** in Spring
Boot when you have multiple applications or environments. It covers the
difference between `@ConditionalOnProperty` and `@Profile`, their use
cases, and detailed examples with configuration.

------------------------------------------------------------------------

## 1. Why Conditional Bean Creation is Needed?

When working with **two applications sharing one common codebase** or
when deploying in **different environments (dev, QA, prod, etc.)**, we
don't want **all beans to be created every time**.\
Instead, we want **only one specific bean** to be created based on
configuration.

There are two main approaches:

1.  **`@ConditionalOnProperty`** â†’ Used when working in the **same
    environment**, but enabling/disabling beans based on properties.
2.  **`@Profile`** â†’ Used when working in **different environments**
    (dev, QA, prod, staging).

------------------------------------------------------------------------

## 2. @ConditionalOnProperty

### Definition

`@ConditionalOnProperty` is used to **conditionally enable or disable a
bean** depending on a property value defined in
`application.properties`.

### Use Case

-   You are in the **same environment** (e.g., dev), but want to choose
    **which database to connect** (SQL or MongoDB).
-   Instead of manually commenting/uncommenting code, Spring Boot will
    read the property and decide.

------------------------------------------------------------------------

### Example: Conditional DB Beans

**Step 1 --- application.properties**

``` properties
sql.enabled=true
mongoDb.enabled=false
```

**Step 2 --- SQL Bean**

``` java
package com.antim.udemySh.service;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

@Component
@ConditionalOnProperty(prefix = "sql", value = "enabled", havingValue = "true", matchIfMissing = false)
public class SQL {
    SQL() {
        System.out.println("SQL DB connected!");
    }
}
```

**Step 3 --- MongoDB Bean**

``` java
package com.antim.udemySh.service;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

@Component
@ConditionalOnProperty(prefix = "mongoDb", value = "enabled", havingValue = "true", matchIfMissing = false)
public class MongoDb {
    MongoDb() {
        System.out.println("MongoDB connected!");
    }
}
```

**Step 4 --- Main DB Bean**

``` java
package com.antim.udemySh.service;

import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import java.util.Objects;

@Component
public class DB {

    @Autowired(required = false)
    SQL sql;

    @Autowired(required = false)
    MongoDb mongo;

    @PostConstruct
    public void init() {
        System.out.println("DB is connected with:");
        System.out.println("SQL: " + Objects.isNull(sql));
        System.out.println("Mongo: " + Objects.isNull(mongo));
    }
}
```

### Output (with sql.enabled=true, mongoDb.enabled=false)

    SQL DB connected!
    DB is connected with:
    SQL: false
    Mongo: true

Here: - `SQL` bean is created. - `MongoDB` bean is not created
(`null`). - `@Autowired(required = false)` is used because otherwise
Spring would throw an error when the bean is missing.

------------------------------------------------------------------------

### How Parameters Work

`@ConditionalOnProperty(prefix = "sql", value = "enabled", havingValue = "true", matchIfMissing = false)`

-   **prefix** â†’ property prefix (`sql`).
-   **value** â†’ actual property name (`enabled`).
-   **havingValue** â†’ value required to enable the bean (`true`).
-   **matchIfMissing** â†’ if property is missing, should it still create
    the bean? (default = false).

ðŸ‘‰ Equivalent in `application.properties`:

``` properties
sql.enabled=true
```

------------------------------------------------------------------------

## 3. @Profile

### Definition

`@Profile` is used to **activate beans only for specific environments**
(dev, QA, prod).

### Use Case

-   You want **different beans/configurations for different
    environments**.
-   Example: Use an **in-memory DB** in `dev`, and a **real DB** in
    `prod`.

------------------------------------------------------------------------

### Multiple `application.properties`

You can create separate property files:

-   `application.properties` (default â†’ parent)
-   `application-dev.properties`
-   `application-qa.properties`
-   `application-prod.properties`

**Default application.properties**

``` properties
username=defaultUsername
password=defaultPassword
```

**application-dev.properties**

``` properties
username=devUsername
password=devPassword
```

**application-qa.properties**

``` properties
username=qaUsername
password=qaPassword
```

**application-prod.properties**

``` properties
username=prodUsername
password=prodPassword
```

------------------------------------------------------------------------

### Example: SQL Bean with Profile

**DB Class**

``` java
package com.antim.udemySh.service;

import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Objects;

@Component
public class DB {
    @Autowired
    SQL sql;

    @PostConstruct
    public void init() {
        System.out.println("DB is connected with:");
        System.out.println("SQL: " + Objects.isNull(sql));
    }
}
```

**SQL Class**

``` java
package com.antim.udemySh.service;

import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

@Component
@Profile("prod")
public class SQL {

    @Value("${username}")
    String username;

    @Value("${password}")
    String password;

    SQL() {
        System.out.println("SQL DB connected!");
    }

    @PostConstruct
    public void init() {
        System.out.println("Username: " + username + " Password: " + password);
    }
}
```

**application.properties**

``` properties
spring.profiles.active=prod
```

**Output**

    SQL DB connected!
    Username: prodUsername Password: prodPassword

------------------------------------------------------------------------

### How Spring Chooses Properties

-   By default â†’ `application.properties` (parent).
-   If `spring.profiles.active=qa` â†’ `application-qa.properties` is
    loaded (child overrides parent).
-   Parent-child relationship â†’ missing values in child are taken from
    parent.

------------------------------------------------------------------------

### Dynamic Profile Selection at Runtime

1.  **Using Command Line**

    ``` sh
    mvn spring-boot:run -Dspring-boot.run.profiles=prod
    ```

2.  **Using `pom.xml` Profiles**

    ``` xml
    <profiles>
        <profile>
            <id>local</id>
            <properties>
                <spring-boot.run.profiles>dev</spring-boot.run.profiles>
            </properties>
        </profile>
        <profile>
            <id>production</id>
            <properties>
                <spring-boot.run.profiles>prod</spring-boot.run.profiles>
            </properties>
        </profile>
        <profile>
            <id>stage</id>
            <properties>
                <spring-boot.run.profiles>qa</spring-boot.run.profiles>
            </properties>
        </profile>
    </profiles>
    ```

    **Run with Maven profile**

    ``` sh
    mvn spring-boot:run -Pproduction
    ```

------------------------------------------------------------------------

### Multiple Profiles

``` properties
spring.profiles.active=prod,qa
```

-   Spring Boot will activate both profiles.
-   Beans with `@Profile("prod")` and `@Profile("qa")` will both be
    created.
-   For properties, the **last one wins** â†’ in this case, `qa`
    overrides.

------------------------------------------------------------------------

## 4. Key Differences

  -----------------------------------------------------------------------------------
  Feature                @ConditionalOnProperty                   @Profile
  ---------------------- ---------------------------------------- -------------------
  **Purpose**            Enable/disable beans in the **same       Enable beans in
                         environment**                            **different
                                                                  environments**

  **Configuration        `application.properties` values          Profile-based
  Source**                                                        property files

  **Granularity**        Fine-grained (per bean, per property)    Environment-wide
                                                                  (group of beans)

  **Industry Usage**     Feature toggling, DB selection, optional Multi-environment
                         beans                                    configs (dev, QA,
                                                                  prod)
  -----------------------------------------------------------------------------------

------------------------------------------------------------------------

## 5. Industry Advantage

-   `@ConditionalOnProperty`: Useful for **feature flags**, **migrating
    databases**, or **optional components** in the same environment.
-   `@Profile`: Useful for **clean separation of environments** and
    **environment-specific beans**.

------------------------------------------------------------------------

âœ… **Conclusion**:\
- Use **`@ConditionalOnProperty`** when toggling features **within the
same environment**.\
- Use **`@Profile`** when managing **different environments** like dev,
QA, and prod.
