# Understanding `@ConditionalOnProperty` in Spring Boot

## ðŸ”¹ Why Do We Need `@ConditionalOnProperty`?

In real-world applications, we often face scenarios where **a bean should only be created if a specific condition is true**. For example:

* Use **SQL Database** in local development.
* Use **MongoDB** in production.
* Enable/Disable certain beans based on **feature flags** or **configuration values**.

Without conditional beans, Spring will always create all beans marked with `@Component`, even if we donâ€™t want them. This can cause **unnecessary resource usage** or **conflicts**.

Thatâ€™s where `@ConditionalOnProperty` comes in.

`@ConditionalOnProperty` tells Spring:
ðŸ‘‰ *"Only create this bean if a certain property in `application.properties` matches a given value."*

---

## ðŸ”¹ Syntax of `@ConditionalOnProperty`

```java
@ConditionalOnProperty(
    prefix = "<propertyPrefix>",
    value = "<propertyName>",
    havingValue = "<expectedValue>",
    matchIfMissing = <true|false>
)
```

### Parameters Explained

* **`prefix`** â†’ Defines the property namespace. Example: `sql`.
* **`value`** â†’ The actual property name inside the prefix. Example: `enabled`.
* **`havingValue`** â†’ The value that must match for the bean to be created. Example: `true`.
* **`matchIfMissing`** â†’ What should Spring do if the property is missing?

  * `false` â†’ Do not create the bean.
  * `true` â†’ Treat as if it matched, and create the bean.

### Example

```properties
sql.enabled=true
mongoDb.enabled=false
```

```java
@Component
@ConditionalOnProperty(prefix = "sql", value = "enabled", havingValue = "true", matchIfMissing = false)
public class SQL {
    SQL(){
        System.out.println("SQL DB connected!");
    }
}
```

ðŸ‘‰ This bean will only be created if `sql.enabled=true` in `application.properties`.

---

# Conditional Bean Creation in Spring Boot

**Problem:** How to create a bean *conditionally* â€” i.e., only create a particular bean when a property or condition is satisfied.

This document converts your notes into a clearer, expanded Markdown guide. Every point from your notes is preserved and explained in detail.

---

## 1) The initial (unconditional) setup â€” everything is created

### Class: `DB.java`

```java
package com.antim.udemySh.service;

import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Objects;

@Component
public class DB {
    @Autowired
    SQL sql;

    @Autowired
    MongoDb mon;

    @PostConstruct
    public void init(){
        System.out.println("DB is connected with :");
        System.out.println("Sql :" + Objects.isNull(sql));
        System.out.println("Mongo :" + Objects.isNull(mon));
    }
}
```

### Class: `MongoDb.java`

```java
package com.antim.udemySh.service;

import org.springframework.stereotype.Component;

@Component
public class MongoDb {
    MongoDb(){
        System.out.println("MongoDb connected!");
    }
}
```

### Class: `SQL.java`

```java
package com.antim.udemySh.service;

import org.springframework.stereotype.Component;

@Component
public class SQL {
    SQL(){
        System.out.println("Sql db connected!");
    }
}
```

### Output (unconditional)

```
Sql db connected!
MongoDb connected!
DB is connected with :
Sql :false
Mongo :false
```

**Explanation:**

* Both `SQL` and `MongoDb` are regular `@Component` classes â€” Spring picks them up during component scan and instantiates both beans.
* `DB` autowires both beans (default `required = true`), so neither is `null` and both print as `false` for `Objects.isNull(...)`.

---

## 2) Desired behavior

We want **only one database bean** to be created based on configuration (for example, only `SQL` when `sql.enabled=true`).

The chosen approach: **use `@ConditionalOnProperty`** (a Spring Boot condition annotation) to enable/disable bean creation based on properties in `application.properties`.

---

## 3) Configure properties

**File:** `application.properties`

```properties
sql.enabled=true
mongoDb.enabled=false
```

**Explanation:**

* These properties control which DB implementation should be active.
* `sql.enabled=true` means we want the `SQL` bean to be created.
* `mongoDb.enabled=false` means we do not want the `MongoDb` bean created.

---

## 4) Annotate beans with `@ConditionalOnProperty`

### Class: `SQL.java` (conditional)

```java
package com.antim.udemySh.service;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

@Component
@ConditionalOnProperty(prefix = "sql", value ="enabled", havingValue = "true", matchIfMissing = false)
public class SQL {
    SQL(){
        System.out.println("Sql db connected!");
    }
}
```

### Class: `MongoDb.java` (conditional)

```java
package com.antim.udemySh.service;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

@Component
@ConditionalOnProperty(prefix = "mongoDb", value = "enabled", havingValue = "true", matchIfMissing = false)
public class MongoDb {
    MongoDb(){
        System.out.println("MongoDb connected!");
    }
}
```

**Detailed explanation of the annotation parameters:**

* `prefix = "sql"` â€” the property name begins with this prefix (so the full property will be `sql.enabled`).
* `value = "enabled"` â€” the rest of the property name (together with prefix it becomes `sql.enabled`).
* `havingValue = "true"` â€” the condition matches only when the property value equals this string. (Note: property values are strings; use `"true"` for boolean `true`.)
* `matchIfMissing = false` â€” if the property is **missing**, the condition **does not match** (i.e., the bean will NOT be created). If you set `matchIfMissing = true`, the bean would be created when the property is absent.

**How to read it in plain English:**

> "Create this bean only if the property `sql.enabled` exists and equals `true`. If `sql.enabled` is missing, do not create the bean."

---

## 5) Make `DB` tolerant of missing beans (`required = false`)

### Updated `DB.java`

```java
package com.antim.udemySh.service;

import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Objects;

@Component
public class DB {
    @Autowired(required = false)
    SQL sql;

    @Autowired(required = false)
    MongoDb mon;

    @PostConstruct
    public void init(){
        System.out.println("DB is connected with :");
        System.out.println("Sql :" + Objects.isNull(sql));
        System.out.println("Mongo :" + Objects.isNull(mon));
    }
}
```

**Why `required = false`?**

* By default `@Autowired` has `required = true` â€” Spring will fail fast if a dependency cannot be satisfied.
* Here we intentionally *may not* have a `MongoDb` or `SQL` bean (depending on configuration). Setting `required = false` tells Spring: "it's okay if this bean is missing â€” inject `null` instead of failing." This allows `DB`'s logic to check for `null` and proceed.

**Important note:** If you keep the default `required = true` and the conditional bean is NOT created, Spring will throw an exception and the application will fail to start.

---

## 6) Resulting output (with `sql.enabled=true` and `mongoDb.enabled=false`)

```
Sql db connected!
DB is connected with :
Sql :false
Mongo :true
```

**Explanation:**

* `SQL` bean was created (because `sql.enabled=true`) â†’ constructor prints `Sql db connected!`.
* `MongoDb` bean was not created (because `mongoDb.enabled=false`) â†’ no `MongoDb connected!` line.
* In `DB.init()`, `Objects.isNull(sql)` is `false` (sql exists) and `Objects.isNull(mon)` is `true` (mongo is null).

---

## 7) Edge cases and failures

* **If both properties are `true`** (`sql.enabled=true` and `mongoDb.enabled=true`): both beans will be created and injected (if `required=true`), or both injected (or null if `required=false`). That means your application will have both DB connections available.

* **If both properties are `false`** and `@Autowired(required = true)` used: application will fail on startup due to missing beans.

* **If both properties are `false`** and `@Autowired(required = false)` used: both fields in `DB` will be `null`; your `DB.init()` must handle `null`s safely.

* **If a property is missing**: with `matchIfMissing = false`, the bean will NOT be created. With `matchIfMissing = true`, absence will be treated as a match (so the bean would be created when property is missing) â€” use this carefully.

---

## 8) Why this approach is useful in the industry

* **Feature toggles & migration:** You can enable/disable components (e.g., move from Mongo to SQL) via configuration without changing code.
* **Lightweight deployments:** Avoid creating unused beans or initializing unnecessary connections in environments where they are not needed (e.g., dev vs production).
* **Third-party integration:** You can turn on/off integrations (databases, messaging systems) based on environment-specific properties.
* **Testing:** Tests can enable only the parts they require.

---

## 9) Related/alternative patterns (shortly)

* **Use `@Profile`** when you want beans enabled by environment profile (e.g., `dev`, `prod`).
* **Use `@ConditionalOnExpression`** when condition uses SpEL (Spring Expression Language), for more complex logic.
* **Use `@Configuration` + `@Bean`** to programmatically return an implementation based on properties (similar to earlier examples), instead of annotating each implementation with `@ConditionalOnProperty`.

---

## 10) Summary â€” step-by-step checklist

1. Decide which property controls the bean (e.g., `sql.enabled`).
2. Add it to `application.properties`.
3. Annotate the implementation with `@ConditionalOnProperty` (set `prefix`, `value`, `havingValue`, `matchIfMissing` appropriately).
4. In the dependent class (`DB`) mark injection as optional with `@Autowired(required = false)` if the bean may be absent.
5. Handle `null` safety in your code (check `Objects.isNull(...)` or use `Optional`/`@Nullable`).

---

# Note - important use of ConditionalOnProperty

* When we have 2 application & 1 common code base, then to make sure bean is only created for 1 application and not for other we use ConditionalOnProperty 
* also we can use @Profile annotation


